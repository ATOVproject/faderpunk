use embassy_executor::Spawner;
use embassy_futures::join::join4;
use embassy_rp::peripherals::USB;
use embassy_rp::usb;
use embassy_usb::class::midi::MidiClass;
use embassy_usb::driver::Driver;
use embassy_usb::msos::{self, windows_version};
use embassy_usb::{Builder, Config as UsbConfig};

use embassy_rp::uart::{Async, BufferedUart, UartTx};

use crate::tasks::midi::{midi_in_task, midi_out_task};

use super::configure::start_webusb_loop;
use super::web_usb::{Config as WebUsbConfig, State as WebUsbState, Url, WebUsb};

// 0x0 (Major) | 0x1 (Minor) | 0x0 (Patch)
// This file is generated by build.rs
// Provides USB_RELEASE_VERSION
include!(concat!(env!("OUT_DIR"), "/version.rs"));

const USB_VENDOR_ID: u16 = 0xf569;
const USB_PRODUCT_ID: u16 = 0x1;
const USB_VENDOR_NAME: &str = "ATOV";
const USB_PRODUCT_NAME: &str = "Faderpunk";
const USB_INTERFACE_GUIDS: &[&str] = &["{3A8E7B0C-F569-4A21-9B7D-6E2C1F8A9D04}"];

pub const USB_MAX_PACKET_SIZE: u16 = 64;

pub struct WebEndpoints<'d, D: Driver<'d>> {
    write_ep: D::EndpointIn,
    read_ep: D::EndpointOut,
}

impl<'d, D: Driver<'d>> WebEndpoints<'d, D> {
    fn new(write_ep: D::EndpointIn, read_ep: D::EndpointOut) -> Self {
        WebEndpoints { write_ep, read_ep }
    }

    pub fn split(self) -> (D::EndpointIn, D::EndpointOut) {
        (self.write_ep, self.read_ep)
    }
}

pub async fn start_transports(
    spawner: &Spawner,
    usb_driver: usb::Driver<'static, USB>,
    uart0: UartTx<'static, Async>,
    uart1: BufferedUart,
    chip_id: u64,
) {
    spawner
        .spawn(run_transports(usb_driver, uart0, uart1, chip_id))
        .unwrap();
}

#[embassy_executor::task]
async fn run_transports(
    usb_driver: usb::Driver<'static, USB>,
    uart0_tx: UartTx<'static, Async>,
    uart1: BufferedUart,
    chip_id: u64,
) {
    // Convert chip ID to hex string for USB serial number
    let mut serial_buf = [0u8; 16];
    let chip_id_bytes = chip_id.to_be_bytes();
    const HEX: &[u8; 16] = b"0123456789ABCDEF";
    for (i, &byte) in chip_id_bytes.iter().enumerate() {
        serial_buf[i * 2] = HEX[(byte >> 4) as usize];
        serial_buf[i * 2 + 1] = HEX[(byte & 0x0F) as usize];
    }
    // Safety: We just filled the buffer with valid ASCII hex chars
    let serial_number = unsafe { core::str::from_utf8_unchecked(&serial_buf) };

    let mut usb_config = UsbConfig::new(USB_VENDOR_ID, USB_PRODUCT_ID);
    usb_config.manufacturer = Some(USB_VENDOR_NAME);
    usb_config.product = Some(USB_PRODUCT_NAME);
    usb_config.serial_number = Some(serial_number);
    usb_config.device_release = USB_RELEASE_VERSION;
    usb_config.max_power = 500;
    usb_config.max_packet_size_0 = USB_MAX_PACKET_SIZE as u8;
    usb_config.device_class = 0xEF;
    usb_config.device_sub_class = 0x02;
    usb_config.device_protocol = 0x01;
    usb_config.composite_with_iads = true;

    // Create embassy-usb DeviceBuilder using the driver and config.
    // It needs some buffers for building the descriptors.
    let mut config_descriptor = [0; 256];
    let mut bos_descriptor = [0; 128];
    let mut msos_descriptor = [0; 256];
    let mut control_buf = [0; 64];

    let webusb_config = WebUsbConfig {
        max_packet_size: USB_MAX_PACKET_SIZE,
        vendor_code: 1,
        landing_url: Some(Url::new("https://faderpunk.io")),
    };

    let mut webusb_state = WebUsbState::new();

    let mut usb_builder = Builder::new(
        usb_driver,
        usb_config,
        &mut config_descriptor,
        &mut bos_descriptor,
        &mut msos_descriptor,
        &mut control_buf,
    );

    // Add msos descriptors for windows compatibility
    usb_builder.msos_descriptor(windows_version::WIN8_1, 0x20);

    // Create classes on the builder.
    let usb_midi = MidiClass::new(&mut usb_builder, 1, 1, USB_MAX_PACKET_SIZE);

    // Configure WebUSB. The order is important here, to give WebUSB a later MI_xx number
    let webusb = WebUsb::configure_with(&mut usb_builder, &mut webusb_state, &webusb_config, |s| {
        s.with_function(|func| {
            func.msos_feature(msos::CompatibleIdFeatureDescriptor::new("WINUSB", ""));
            func.msos_feature(msos::RegistryPropertyFeatureDescriptor::new(
                "DeviceInterfaceGUIDs",
                msos::PropertyData::RegMultiSz(USB_INTERFACE_GUIDS),
            ));
        })
        .with_alt(None, |alt| {
            let write_ep = alt.endpoint_bulk_in(None, USB_MAX_PACKET_SIZE);
            let read_ep = alt.endpoint_bulk_out(None, USB_MAX_PACKET_SIZE);
            WebEndpoints::new(write_ep, read_ep)
        })
    });

    let mut usb = usb_builder.build();

    let (usb_tx, usb_rx) = usb_midi.split();
    let (uart1_tx, uart1_rx) = uart1.split();

    // let midi_fut = start_midi_loops(usb_midi, uart0, uart1);
    let midi_out_fut = midi_out_task(usb_tx, uart0_tx, uart1_tx);
    let midi_in_fut = midi_in_task(usb_rx, uart1_rx);
    let webusb_fut = start_webusb_loop(webusb);

    join4(usb.run(), midi_in_fut, midi_out_fut, webusb_fut).await;
}
